import { Component, OnInit } from '@angular/core';
import { PictureService } from '../services/picture.service';
import { Observable } from 'rxjs/Observable';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/catch';
import * as d3 from 'd3';

@Component({
  selector: 'app-family-tree',
  templateUrl: './family-tree.component.html',
  styleUrls: ['./family-tree.component.scss'],
  providers: [PictureService]
})
export class FamilyTreeComponent implements OnInit {
  public treeData;
  public testData: any[] = [];
  tree;
  boxWidth;
  boxHeight;
  root;
  svg;
  duration;

  constructor(private _pictureService: PictureService) {
  // this.getSternbergCollection();
}

ngOnInit() {
  console.log('Family Tree Yay!');

  let root;
  const boxWidth = 150,
    boxHeight = 40,
    duration = 750; // duration of transitions in ms

  // Setup zoom and pan
  const zoom = d3
    .zoom()
    .scaleExtent([0.1, 1])
    .on('zoom', function() {
      svg.attr('transform', d3.event.scale);
    });
  // Offset so that first pan and zoom does not jump back to the origin
  // .translate([150, 200]);

  const svg = d3
    .select('body')
    .append('svg')
    .attr('width', 1000)
    .attr('height', 500)
    .call(zoom)
    .append('g')

    // Left padding of tree so that the whole root node is on the screen.
    // TODO: find a better way
    .attr('transform', 'translate(150,200)');

  const tree = d3
    .tree()

    // Using nodeSize we are able to control
    // the separation between nodes. If we used
    // the size parameter instead then d3 would
    // calculate the separation dynamically to fill
    // the available space.
    .nodeSize([100, 200])

    // By default, cousins are drawn further apart than siblings.
    // By returning the same value in all cases, we draw cousins
    // the same distance apart as siblings.
    .separation(function() {
      return 0.5;
    })

    // Tell d3 what the child nodes are. Remember, we're drawing
    // a tree so the ancestors are child nodes.
    .children(function(person) {
      // If the person is collapsed then tell d3
      // that they don't have any ancestors.
      if (person.collapsed) {
        return;
      } else {
        return person._parents;
      }
    });

  this.tree = tree;
  this.svg = svg;
  this.boxWidth = boxWidth;
  this.boxHeight = boxHeight;
  this.duration = duration;

  d3.json('data/8gens.json', function(error, json) {
    if (error) {
      return console.error(error);
    }

    // Start with only the first few generations showing
    json._parents.forEach(function(gen2) {
      gen2._parents.forEach(function(gen3) {
        this.collapse(gen3);
      });
    });
    root = json;
    root.x0 = 0;
    root.y0 = 0;
    console.log('Family Tree Yay! json ', root);
    this.draw(root);
  });
  this.root = root;
}

getSternbergCollection(): void {
  this._pictureService.getFamilyContents().subscribe(data => {
  // this.treeData = data.map(d => {
  //     console.log('getFamilyContents ', d);
  //     return d;
  // });
  this.treeData = data.Sternberg;

  this.testData.push(data.Sternberg);

  console.log('getFamilyContents ', this.treeData);
});
}

draw(source) {
  const nodes = this.tree.nodes(this.root),
    links = this.tree.links(nodes);

  // Update links
  const link = this.svg
    .selectAll('path.link')

    // The function we are passing provides d3 with an id
    // so that it can track when data is being added and removed.
    // This is not necessary if the tree will only be drawn once
    // as in the basic example.
    .data(links, function(d) {
      return d.target.id;
    });

  // Add new links
  // Transition new links from the source's
  // old position to the links final position
  link
    .enter()
    .append('path')
    .attr('class', 'link')
    .attr('d', d => {
      const o = { x: source.x0, y: source.y0 + this.boxWidth / 2 };
      return this.transitionElbow({ source: o, target: o });
    });

  // Update the old links positions
  link
    .transition()
    .duration(this.duration)
    .attr('d', this.elbow);

  // Remove any links we don't need anymore
  // if part of the tree was collapsed
  // Transition exit links from their current position
  // to the source's new position
  link
    .exit()
    .transition()
    .duration(this.duration)
    .attr('d', function(d) {
      const o = { x: source.x, y: source.y + this.boxWidth / 2 };
      return this.transitionElbow({ source: o, target: o });
    })
    .remove();

  // Update nodes
  const node = this.svg
    .selectAll('g.person')

    // The function we are passing provides d3 with an id
    // so that it can track when data is being added and removed.
    // This is not necessary if the tree will only be drawn once
    // as in the basic example.
    .data(nodes, function(person) {
      return person.id;
    });

  // Add any new nodes
  const nodeEnter = node
    .enter()
    .append('g')
    .attr('class', 'person')

    // Add new nodes at the right side of their child's box.
    // They will be transitioned into their proper position.
    .attr('transform', function(person) {
      return 'translate(' + (source.y0 + this.boxWidth / 2) + ',' + source.x0 + ')';
    })
    .on('click', this.togglePerson);

  // Draw the rectangle person boxes.
  // Start new boxes with 0 size so that
  // we can transition them to their proper size.
  nodeEnter.append('rect').attr({
    x: 0,
    y: 0,
    width: 0,
    height: 0
  });

  // Draw the person's name and position it inside the box
  nodeEnter
    .append('text')
    .attr('dx', 0)
    .attr('dy', 0)
    .attr('text-anchor', 'start')
    .attr('class', 'name')
    .text(function(d) {
      return d.name;
    })
    .style('fill-opacity', 0);

  // Update the position of both old and new nodes
  const nodeUpdate = node
    .transition()
    .duration(this.duration)
    .attr('transform', function(d) {
      return 'translate(' + d.y + ',' + d.x + ')';
    });

  // Grow boxes to their proper size
  nodeUpdate.select('rect').attr({
    x: -(this.boxWidth / 2),
    y: -(this.boxHeight / 2),
    width: this.boxWidth,
    height: this.boxHeight
  });

  // Move text to it's proper position
  nodeUpdate
    .select('text')
    .attr('dx', -(this.boxWidth / 2) + 10)
    .style('fill-opacity', 1);

  // Remove nodes we aren't showing anymore
  const nodeExit = node
    .exit()
    .transition()
    .duration(this.duration)

    // Transition exit nodes to the source's position
    .attr('transform', function(d) {
      return 'translate(' + (source.y + this.boxWidth / 2) + ',' + source.x + ')';
    })
    .remove();

  // Shrink boxes as we remove them
  nodeExit.select('rect').attr({
    x: 0,
    y: 0,
    width: 0,
    height: 0
  });

  // Fade out the text as we remove it
  nodeExit
    .select('text')
    .style('fill-opacity', 0)
    .attr('dx', 0);

  // Stash the old positions for transition.
  nodes.forEach(function(person) {
    person.x0 = person.x;
    person.y0 = person.y;
  });
}

/**
 * Update a person's state when they are clicked.
 */
togglePerson(person) {
  if (person.collapsed) {
    person.collapsed = false;
  } else {
    this.collapse(person);
  }
  this.draw(person);
}

/**
 * Collapse person (hide their ancestors). We recursively
 * collapse the ancestors so that when the person is
 * expanded it will only reveal one generation. If we don't
 * recursively collapse the ancestors then when
 * the person is clicked on again to expand, all ancestors
 * that were previously showing will be shown again.
 * If you want that behavior then just remove the recursion
 * by removing the if block.
 */
collapse(person) {
  person.collapsed = true;
  if (person._parents) {
    person._parents.forEach(this.collapse);
  }
}

/**
 * Custom path function that creates straight connecting
 * lines. Calculate start and end position of links.
 * Instead of drawing to the center of the node,
 * draw to the border of the person profile box.
 * That way drawing order doesn't matter. In other
 * words, if we draw to the center of the node
 * then we have to draw the links first and the
 * draw the boxes on top of them.
 */
elbow(d) {
  const sourceX = d.source.x,
    sourceY = d.source.y + this.boxWidth / 2,
    targetX = d.target.x,
    targetY = d.target.y - this.boxWidth / 2;

  return 'M' + sourceY + ',' + sourceX + 'H' + (sourceY + (targetY - sourceY) / 2) + 'V' + targetX + 'H' + targetY;
}

/**
 * Use a different elbow function for enter
 * and exit nodes. This is necessary because
 * the function above assumes that the nodes
 * are stationary along the x axis.
 */
transitionElbow(d) {
  return 'M' + d.source.y + ',' + d.source.x + 'H' + d.source.y + 'V' + d.source.x + 'H' + d.source.y;
}
}
